/**
 * rethink-init
 */

/**
 * Module dependencies
 */

var Queue   = require('seed-queue');
var extend  = require('seed-extend');
var log     = require('debug')('rethink-init');

/**
 * Helpers
 */

function buildIndex(index) {
  if (index === true) {
    return { 
      multi: false, 
      geo: false
    };
  } else {
    return extend({ 
      geo: false, 
      multi: false
    }, index);
  }
}

function createTable(tableName) {
  return function(schema, r, conn, next) {
    var options = schema[tableName].options || {};
    r.tableCreate(tableName, options).run(conn, function(err, result) {
      if (err) {
        if (err.msg.match(/Table (.*) already exists./)) {
          log('Table %s exists', tableName);
          if (options.shards || options.replicas) {
            r.table(tableName).reconfigure({
              shards: options.shards, 
              replicas: options.replicas
            }).run(conn, function(err) {
              if (err) return next(err);
              if (!options.durability) {
                log('Table %s reconfigured', tableName);
                return next();
              }
              r.table(tableName).config({
                durability: options.durability
              }).exec(conn, function(err) {
                if (err) return next(err);
                next();
              });
            });
          } else {
            next();
          }
        } else {
          if (!options.durability) {
            return next();
          }
          r.table(tableName).config({
            durability: options.durability
          }).exec(conn, function(err) {
            if (err) return next(err);
            next();
          });
        }
      } else {
        log('Table %s created', tableName);
        next();
      }
    });
  }
}

function createIndex(tableName, indexName) {
  return function(schema, r, conn, next) {
    var index = buildIndex(schema[tableName].indexes[indexName]);
    r.table(tableName).indexCreate(indexName, index).run(conn, function(err, result) {
      if (err) return next(err);
      log('Index %s in table %s created', indexName, tableName);
      next();
    });
  }
}

function rebalance(tableName) {
  return function(schema, r, conn, next) {
    r.table(tableName).rebalance().run(conn, function(err, result) {
      if (err) return next(err);
      log('Table %s rebalanced', tableName);
      next();
    });
  }
}

function resetIndex(tableName, indexName) {
  return function(schema, r, conn, next) {
    var index = buildIndex(schema[tableName].indexes[indexName]);
    r.table(tableName).indexDrop(indexName).run(conn, function(err) {
      if (err) return next(err);
      r.table(tableName).indexCreate(indexName, index).run(conn, function(err) {
        if (err) return next(err);
        log('Index %s in table %s has been updated', indexName, tableName);
        next();
      });
    });
  }
}

function syncIndex(tableName, indexName) {
  return function(schema, r, conn, next) {
    r.table(tableName).indexStatus(indexName).run(conn, function(err, results) {
      if (err) {
        if (err.msg.match(/Index (.*) was not found on table (.*)./)) {
          createIndex(tableName, indexName)(schema, r, conn, next);
        } else {
          return next(err);
        }
      } else {
        var existingIndex = results[0];
        var index = buildIndex(schema[tableName].indexes[indexName]);
        if (index.multi !== existingIndex.multi || index.geo !== existingIndex.geo) {
          resetIndex(tableName, indexName, results[0])(schema, r, conn, next);
        } else {
          next();
        }
      }
    });
  }
}

function awaitIndex(tableName) {
  return function(schema, r, conn, next) {
    log('Waiting for indexes of table %s to build', tableName);
    r.table(tableName).indexWait().run(conn, function(err) {
      if (err) return next(err);
      log('Done waiting for indexes of table %s', tableName);
      next();
    });
  }
}

function findAndRemoveUnusedIndexes(tableName, indexNames) {
  return function(schema, r, conn, next) {
    r.table(tableName).indexList().run(conn, function(err, list) {
      if (err) return next(err);
      var unused = list.filter(function(indexName) {
        return indexNames.indexOf(indexName) === -1;
      });
      if (!unused.length) return next();
      var queue = new Queue();
      unused.forEach(function(indexName) {
        queue.add(function(next) {
          r.table(tableName).indexDrop(indexName).run(conn, function(err) {
            if (err) return next(err);
            next();
          });
        });
      });
      queue.end(function(err) {
        if (err) return next(err);
        next();
      });
    });
  }
}

/**
 * Initialize a sync indexes from schema
 *
 * @param {Object} schema, database table schema
 * @param {Object} r, rethinkdb driver
 * @param {Object} conn, rethinkdb connection
 * @param {Function} cb, callback(err, conn)
 */

function init(schema, r, conn, cb) {
  var queue = new Queue(schema, r, conn);
  
  Object.keys(schema).forEach(function(tableName) {
    queue.add(createTable(tableName));
    queue.add(rebalance(tableName));
    queue.add(awaitIndex(tableName));
    var indexNames = Object.keys(schema[tableName].indexes).map(function(indexName) {
      queue.add(syncIndex(tableName, indexName));
      return indexName;
    });
    queue.add(findAndRemoveUnusedIndexes(tableName, indexNames));
    queue.add(awaitIndex(tableName));
  });
  
  queue.end(function(err) {
    if (err) return cb(err);
    cb(null, conn);
  });
}

/**
 * Expose
 */

exports = module.exports = init;